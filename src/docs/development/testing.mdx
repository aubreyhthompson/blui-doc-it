# Testing Your PX Blue Applications

<!-- KEYWORDS: testing test unit e2e -->

Testing is an important part of building an application, but unfortunately, it usually does not receive as much attention as it should. Testing should be considered from the very beginning of development, not as an afterthought once development is finished. In general, every time you write a new piece of code or update existing code, you should also write a test that verifies that your code is correct.

Tests come in a variety of different flavors. The following sections discuss Unit Tests and End-to-End (E2E) Tests.

## Unit Testing

Unit testing focuses on testing small pieces of your feature (such as testing that functions return the expected values for various inputs). These will likely make up the bulk of your tests. They are quick to write, easy to automate, and can help you achieve significant code coverage.

Angular, React, and React Native all come with built-in unit testing frameworks (if you are using the respective CLI tools). Ionic can be unit tested using the same tools you would use for a standard Angular application.

For consistency, you should stick to using these standard tools unless you have a good reason for using alternatives.

## When To Unit Test

When to write unit tests depends on the software development approach and for most a unit test should be written when there is a working feature or code change to a feature. Unit testing for some development following the TDD or BDD methodologies can write unit tests prior to a working feature.

Test Driven Development “TDD” methodology unit tests are written before any implementation of code for a feature.

Behavior Driven Development “BDD” methodology unit test are written before any implementation of code for a feature and after the feature story has been written.

The methodologies are not always followed due to type of feature or application being developed but instead the unit test outcome should provide confidence that the code and design are working as intended without issues in any scenario. 

Write unit tests in a way that they test the render logic and not the internal implementation. The test should be testing the things that the user will be viewing and interacting with.

Let’s say you are testing a component that displays a button on the screen and when the user clicks the button, your component renders a message in a div element.

Your test should check practically for the same,  check if the button is clickable and if the div exists after clicking the button.

Example component with a button.

- We should test what the user views i.e. rendering and what the user can do i.e. interactions.

- If there is visual change after clicking , test for it.

- If there is a value returned after clicking, test for it.

```sh
It(‘should display message on button click’, () =>{
const wrapper = mount(<my-component />);
const submitButton = wrapper.find(button);
submitButton.simulate(‘click’);
expect(message.prop(enabled)).toBeTruthy();
```

### Integration Test

Unit testing is testing the smallest single amount of code or behavior as possible, usually at a method level. A unit test shouldn't have any dependencies on anything external, such as other methods from another feature or APIs. The reason for not having dependencies on anything else is that if the unit test fails, it's easy to know where it failed.

When you start combining two or more pieces of logic from features together, it gets you into integration testing.

### Angular

The Angular CLI comes pre-configured with Jasmine and Karma for unit testing. When you create a new project, sample tests are created in your project for you (test files are identified by the `.spec.ts` file extension). You can execute the tests by running the following in your terminal:

```sh
cd your/project/root
ng test
```

This will build your app and launch the browser with the test runner. For more detailed information on writing test cases, see the documentation for [Jasmine](https://jasmine.github.io/2.0/introduction) and [Karma](https://karma-runner.github.io/latest/index.html).

### React

The Create React App CLI is pre-configured with the Jest testing framework. When creating a new project, a sample test is created in your project for you (test files are identified by the `.test.js` file extension). You can execute the tests by running the following in your terminal:

```sh
cd your/project/root
npm run test
// or
yarn test
```

This will run your tests and show the pass/fail output in the terminal.

There are additional test utilities that complement Jest well. Create React App provides access to `react-testing-library` through the `react-dom` dependency. The PX Blue team has also made use of Enzyme, a testing framework created by AirBnB, and Test Renderer.

For detailed information, refer to the [Jest](https://github.com/facebook/jest), [Running React Tests](https://facebook.github.io/create-react-app/docs/running-tests), [Enzyme](https://airbnb.io/enzyme/), [react-testing-library](https://github.com/kentcdodds/react-testing-library), and [Test Renderer](https://reactjs.org/docs/test-renderer.html) documentation.

### React Native

Like React, the React Native CLI also bundles Jest into your application. Most of the testing strategies and libraries can be shared between the two frameworks.

### Ionic

When creating an Ionic project with Angular, the Angular CLI is used to generate the underlying project, so you have access to all the same testing tools as you would with a regular Angular project.

## End-to-End Testing
End-to-End tests are a higher level test than Unit Tests. They focus primarily on the flow of the application, making sure that the different parts of the application work together correctly. 

For example, you may test that clicking a login button takes you to the appropriate sign-in page. Tests usually take the form of automated GUI tests that run against a live system and in web context, an end-to-end test runner often remotely automates a browser. That means that classic unit testing tools like mocking, stubbing, access to internal state are generally unavailable.

End-to-end tests should be covering areas around user stories that span many components and views like signing up for user accounts, logging in and out of the application, updating a user’s profile information or any user workflow where multiple components are tested together to achieve the business logic or functionality outcome.

General End-to-End tests are defined for Acceptance testing for customer expectations and Regression testing for preventing regression errors during development.

### Breakable Selectors
In the web application context, there are several ways to find an element and they aren’t all equal and brittle to changes in the UI.

The CSS selector e.g. ```.sign-in-btn```
Classes are liable to change, so these are liable to break.

The ```:nth-child()``` selector. Orderings of elements at the same hierarchical level seems to be subject to error messages from your test runner harder to understand.

The element selector ```<mat-icon _ngcontent-c6="" class="mat-icon material-icons" role="img" aria-hidden="true">delete</mat-icon>``` is subject to change and becomes an issue if there are several delete buttons on a single page or when the page refreshes.

The xPath selector ```/html/body/app/footer/div/button[1]``` is also subject change and can become an issue over time as the application UI changes.

The ID selector ```#thumbnail``` It seems like IDs almost never change, but they can. There may also be other reasons to avoid adding them to elements, such as if the UI framework you are using inserts and relies on them internally.

The ```data-test=”some-unique-id”``` attribute. This is an attribute added to the target element and gives the test a handle. It can be as descriptive as you want, and the test will be able to find it. It is totally impervious to changes in layout, ID, styles, and even element type.

A common pain point in UI test automation and end-to-end testing is that modern Javascript platforms are constantly changing, particularly in the open source community. The majority of front-end development frameworks auto-generate IDs and classes for components that are used internally, but this can make it difficult to locate elements via test automation tooling. Identifying elements by these values (e.g., using IDs, CSS or xPath locators "without" property attributes) makes your tests brittle because they are subject to change any time a new version comes out (or even any time the page is refreshed).

Working with web-driver types of testing frameworks will require additional tools to help identify elements on a page, such as Selenium's page object generator or browser developer tools that assists in writing tests. 

### Examples of common elements and finding selectors 
For example, identifying a delete button:

1) Selenium page object generator via css:
        
        @FindBy(css = "app footer.mat-simple-snackbar div button:nth-of-type(1)") @CacheLookup private WebElement delete;
        
2) Browser developer tools via element:
        
        <mat-icon _ngcontent-c6="" class="mat-icon material-icons" role="img" aria-hidden="true">delete</mat-icon>
        
3) Browser developer tools via selector:
        
        body > app > footer > div > button:nth-child(1) > span > mat-icon
        
4) Browser developer tools via xPath:
        
        /html/body/app/footer/div/button[1]


The common example above will require additional work to use in a web-driver type framework automation test. It will require changes to the TypeScript or Javascript code to provide unique IDs (and some Javascript platforms will actually override these with their automatically generated IDs anyway). If you have an existing application, going back and making (potentially) breaking changes (i.e., changing element IDs) to the code is not desirable. With web-driver testing type frameworks, you can simply add a "dev-id" to the element's html and use that ID as the unique identifying characteristic for the selector.
Example:
```
<div>
    <button mat-icon-button (click)="deleteItems()" dev-id="snackbar-delete-btn">
        <mat-icon>delete</mat-icon>
    </button>
</div>

```

After adding the "dev-id" to the element, the identification of the delete button will never have to change, making it safe even if the underlying component code changes. When you inspect the web element via developer tools you will now see the "dev-id" in the attribute’s property of the element, containing nodeValue="snackbar-delete-btn". This approach is common and now the delete button can be called by its locator and selector via ID, CSS or xPath making it more reliable because it contains a structure-based location with a custom attribute of "dev-id".
Example of the element with dev-id:
```
<button _ngcontent-c6="" dev-id="snackbar-delete-btn" mat-icon-button="" class="mat-icon-button">
    <span class="mat-button-wrapper">
        <mat-icon _ngcontent-c6="" class="mat-icon material-icons" role="img" aria-hidden="true">delete</mat-icon>
    </span>
    <div class="mat-button-ripple mat-ripple mat-button-ripple-round" matripple="" ng-reflect-centered="true" ng-reflect-disabled="false" ng-reflect-trigger="[object HTMLButtonElement]"></div>
    <div class="mat-button-focus-overlay"></div>
</button>

```
Example of use in a test
```
getDeleteButton() {return element(by.css('button.mat-icon-button:nth-of-type(1)')).getId(dev-id);})

WebElement click = driver.findelement(by.css('button.mat-icon-button:nth-of-type(1)')).click();

WebElement click = driver.findElement(By.id("snackbar-delete-btn")).click();

WebElement click = driver.findElement(By.xpath("//button[contains(@dev-id='snackbar-delete-btn')]")).click();

```
End-to-End tests take long to run because they test the system end-to-end, integrating with all the various parts and subsystems the application relies on to enable the user workflow being tested. It is recommended to optimize your integration pipeline to run in parallel so that it can complete quicker. In some cases where End-to-End tests are very long, they should be divided up by logic to test smaller pieces of functionality when possible.

Functional tests without unit tests can never provide deep enough code coverage to be confident that you have an adequate regression safety net for continuous delivery. Unit tests provide code coverage depth. Functional tests provide user requirement test case coverage breadth.


### Cypress

Cypress is an open source testing framework that boasts support for any modern JavaScript framework. It works well for E2E tests in both Angular and React applications and is easier to use than some of the more traditional tools, such as Selenium.

For a more detailed write-up on Cypress, check out the official [Cypress Documentation](https://docs.cypress.io/guides/getting-started/installing-cypress.html#System-requirements).
