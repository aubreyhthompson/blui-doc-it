import { DemoCard, ImageGrid, MaterialDesignDescription, Divider, TOC } from '../../app/components';

import BannerImage from '../../app/assets/design-patterns/tables/tables.svg';
import StandardTable from '../../app/assets/design-patterns/tables/standard-table.png';

<!-- Behaviors -->

import TableCellText from '../../app/assets/design-patterns/tables/table-cell-text.png';
import TableCellNumber from '../../app/assets/design-patterns/tables/table-cell-number.png';
import TableCellTextField from '../../app/assets/design-patterns/tables/table-cell-text-field.png';
import TableCellSwitch from '../../app/assets/design-patterns/tables/table-cell-switch.png';
import TableCellStatus from '../../app/assets/design-patterns/tables/table-cell-status.png';
import TableCellIcon from '../../app/assets/design-patterns/tables/table-cell-icon.png';
import TableCellMultiSelect from '../../app/assets/design-patterns/tables/table-cell-multi-select.png';
import TableCellStripe from '../../app/assets/design-patterns/tables/table-cell-stripe.png';
import TableCellUnderlinedField from '../../app/assets/design-patterns/tables/table-cell-underlined-field.png';
import TableCellImage from '../../app/assets/design-patterns/tables/table-cell-image.png';
import ActionOnHover from '../../app/assets/design-patterns/tables/action-on-hover.png';
import ActionAtRowEnd from '../../app/assets/design-patterns/tables/action-at-row-end.png';
import BatchAction1 from '../../app/assets/design-patterns/tables/batch-action-1.png';
import BatchAction2 from '../../app/assets/design-patterns/tables/batch-action-2.png';
import StickyHeader from '../../app/assets/design-patterns/tables/sticky-header.gif';
import HorizontalScrollBar from '../../app/assets/design-patterns/tables/horizontal-scroll-bar.png';
import StickyCheckbox from '../../app/assets/design-patterns/tables/sticky-checkbox.gif';
import StickyRowAction from '../../app/assets/design-patterns/tables/sticky-row-action.gif';
import ClickArea1 from '../../app/assets/design-patterns/tables/click-area-1.png';
import ClickArea2 from '../../app/assets/design-patterns/tables/click-area-2.png';
import Filter1 from '../../app/assets/design-patterns/tables/filter-1.png';
import Filter2 from '../../app/assets/design-patterns/tables/filter-2.png';
import Filter3 from '../../app/assets/design-patterns/tables/filter-3.png';
import Filter4 from '../../app/assets/design-patterns/tables/filter-4.png';
import AdvancedTableFilter from '../../app/assets/design-patterns/tables/advanced-table-filter.gif';
import Drag1 from '../../app/assets/design-patterns/tables/drag-1.png';
import Drag2 from '../../app/assets/design-patterns/tables/drag-2.png';
import AdditionAnimation from '../../app/assets/design-patterns/tables/addition-animation.gif';
import SubstractionAnimation from '../../app/assets/design-patterns/tables/substraction-animation.gif';
import ExpandedRow from '../../app/assets/design-patterns/tables/expanded-row.gif';
import ExpandedRowTooComplicated from '../../app/assets/design-patterns/tables/expanded-row-too-complicated.png';
import ExpandedRowActions from '../../app/assets/design-patterns/tables/expanded-row-actions.png';

<!-- Tables vs. Lists -->

import ListVTableTable from '../../app/assets/design-patterns/tables/list-v-table-table.png';
import ListVTableList from '../../app/assets/design-patterns/tables/list-v-table-list.png';
import ArrangeTable from '../../app/assets/design-patterns/tables/arrange-table.svg';
import ArrangeList from '../../app/assets/design-patterns/tables/arrange-list.svg';
import DashboardTable from '../../app/assets/design-patterns/tables/dashboard-table.png';
import PageBodyTable from '../../app/assets/design-patterns/tables/page-body-table.png';
import ReadTable from '../../app/assets/design-patterns/tables/read-table.svg';
import ReadList from '../../app/assets/design-patterns/tables/read-list.svg';
import ColumnOrder1 from '../../app/assets/design-patterns/tables/column-order-1.png';
import ColumnOrder2 from '../../app/assets/design-patterns/tables/column-order-2.png';
import ImplicitValueTable from '../../app/assets/design-patterns/tables/implicit-value-table.png';
import ImplicitValueList from '../../app/assets/design-patterns/tables/implicit-value-list.png';
import TabularList from '../../app/assets/design-patterns/tables/tabular-list.png';

<!-- Responsive -->

import TableOnMobile from '../../app/assets/design-patterns/tables/table-on-mobile.svg';
import HomePagePreview from '../../app/assets/design-patterns/tables/home-page-preview.gif';
import TableStackedAsList from '../../app/assets/design-patterns/tables/table-stacked-as-list.gif';
import MobilePagination from '../../app/assets/design-patterns/tables/mobile-pagination.png';
import LandscapeTable from '../../app/assets/design-patterns/tables/landscape-table.gif';
import InviteToLandscapeX from '../../app/assets/design-patterns/tables/invite-to-landscape-x.png';
import InviteToLandscapeCountdown from '../../app/assets/design-patterns/tables/invite-to-landscape-countdown.gif';

<!-- Specs -->

import SpecSize from '../../app/assets/design-patterns/tables/spec-size.png';
import SpecTypography from '../../app/assets/design-patterns/tables/spec-typography.png';
import SpecPagination from '../../app/assets/design-patterns/tables/spec-pagination.png';

# Tables

<ImageGrid images={[BannerImage]} regularWidth />

Similar to [lists](patterns/lists), tables are used to display structured data. Tables are especially powerful in desktop applications, where users can easily compare and analyze a large set of data and navigate with sorting and filtering options.

<React.Fragment>
    <MaterialDesignDescription title={'Data Table'} url={`https://material.io/components/data-tables`} />
    <TOC
        anchors={[
            { title: 'Introduction', hash: '#tables' },
            { title: 'Behaviors' },
            { title: 'Table Cell Contents', depth: 1 },
            { title: 'Row Actions', depth: 1 },
            { title: 'Batch Actions', depth: 1 },
            { title: 'Sticky Header Row', depth: 1 },
            { title: 'Expanded Row', depth: 1 },
            { title: 'Horizontal Scrolling', depth: 1 },
            { title: 'Searching and Filtering', depth: 1 },
            { title: 'Transition Animation', depth: 1 },
            { title: 'Tables vs. Lists' },
            { title: 'Responsive' },
            { title: 'Design Specifications' },
            { title: 'Developers' },
        ]}
    />
    <Divider />
</React.Fragment>

# Behaviors

<ImageGrid images={[StandardTable]} caption={`A basic table.`} regularWidth />

## Table Cell Contents

Table cells may be dynamic and interactive.

<ImageGrid
    images={[
        TableCellText,
        TableCellNumber,
        TableCellTextField,
        TableCellSwitch,
        TableCellStatus,
        TableCellIcon,
        TableCellMultiSelect,
        TableCellStripe,
    ]}
    captionsUnderImages={[
        'Text content. The alternating background color is optional.',
        'Numerical value. Note that both the header and the text cells are right-aligned.',
        'Text fields. Note that text fields are right-aligned as they are expecting numerical values. These rows are also taller than standard table rows.',
        'Switches and checkboxes.',
        'Icons and tags.',
        'Icon buttons at the end of the table row for touch screens.',
        `Checkboxes to select rows.`,
        `Status stripes for row items with special statuses.`,
    ]}
    gridImageProps={{ sm: 6, md: 4 }}
/>

You should seek to make your tables both easy to navigate and effective to use.

<ImageGrid
    images={[TableCellUnderlinedField, TableCellImage]}
    captionsUnderImages={[
        'CAUTION: Be careful when using underlined text fields in a table, as their understrokes compete with the line strokes between each table row.',
        `AVOID: Images can heighten table rows. Consider using a list instead.`,
    ]}
/>

## Row Actions

Similar to lists, tables also have row actions. Common row actions include edit, delete and view details. They are usually placed at the end of a table row.

<ImageGrid
    images={[ActionAtRowEnd, ActionOnHover]}
    captionsUnderImages={[
        `Row actions can be placed at the end of the row.`,
        `DO: On desktop, you can choose to have row actions visible only when the mouse is hovering on the row. The buttons won't compete for rooms with the rest of the table.`,
    ]}
/>

<ImageGrid
    images={[Drag1, Drag2]}
    caption={[
        `Drag-and-drop actions are usually placed at the beginning of a row. If you have row numbers, you may choose to display the drag handle on hover.`,
    ]}
/>

## Batch Actions

If your application allows users to perform batch actions to their data set, such as deleting 15 items at once, you can add a checkbox column on the left rim of the table.

<ImageGrid
    images={[BatchAction1, BatchAction2]}
    captionsUnderImages={[
        `Buttons are disabled when no rows are checked.`,
        `Buttons become enabled when rows are checked. Optionally, use theme color to highlight the selected row, and label the button with the number of items selected to account for pagination.`,
    ]}
/>

You may change the clickable area when users are cognitively loaded and busy deciding which row to check. When they enter this "batch action mode", increase the row selection area so that it is easier to select.

<ImageGrid
    images={[ClickArea1, ClickArea2]}
    captionsUnderImages={[
        `When nothing is selected, the selection target area is limited to the region around the checkbox.`,
        `When a row is selected, the application enters this "batch action mode", and users can select other rows by clicking anywhere on those rows.`,
    ]}
/>

## Sticky Header Row

When a table gets long, your users should not need to scroll back to the top to view the table header.

<ImageGrid
    images={[StickyHeader]}
    caption={[`Use sticky headers to help your users navigate through the table.`]}
    regularWidth
/>

## Expanded Row

Occasionally, table rows may expand to allow users _take a quick peek_ into small row details.

<ImageGrid
    images={[ExpandedRow]}
    caption={[`Use sticky headers to help your users navigate through the table.`]}
    regularWidth
/>

<ImageGrid
    images={[ExpandedRowTooComplicated, ExpandedRowActions]}
    captionsUnderImages={[
        `DONT: Do not include complicated contents in an expanded row, as this will break the efficiency of a table. In this case, you should design a dedicated page for the content.`,
        `DONT: Do not surprise your users by hiding high priority actions in the expanded row space.`,
    ]}
/>

## Horizontal Scrolling

When your table overflows horizontally, you should allow your users to scroll horizontally to view more about the table. However, this interaction is less ergonomically convenient when users are not using a touch screen or a trackpad. See the [Responsive](#responsive) section below.

The application may display a scroll bar to suggest that there are more contents to the right.

<ImageGrid
    images={[HorizontalScrollBar]}
    caption={[`Place horizontal scroll bar between rows and the footer / pagination area.`]}
    regularWidth
/>

<ImageGrid
    images={[StickyCheckbox, StickyRowAction]}
    captionsUnderImages={[
        `The checkbox column should be sticky to the left as the user scrolls to the right.`,
        `The action column, if designed to be always visible, should be sticky to the right. Do not include too many row actions that cover excessive table body area.`,
    ]}
/>

## Searching and Filtering

There are many different ways to perform searching and filtering with table data. Below are a few examples:

<ImageGrid
    images={[Filter1, Filter2, Filter3, Filter4]}
    captionsUnderImages={[
        `A simple search field embedded in a table.`,
        `A search field outside a table.`,
        `Filter criteria listed as chips.`,
        `A "saved filter" dropdown.`,
    ]}
/>

<ImageGrid
    images={[AdvancedTableFilter]}
    caption={[
        `You may combine multiple interactions (searching and filtering) and input methods (keyboard navigations, keyboard typing, mouse clicking) together for an "advanced search".`,
    ]}
    regularWidth
/>

## Transition Animation

Often, table data look highly similar between rows and can disorient your users. You are encouraged to use animations in your applications to help users understand certain transitions.

<ImageGrid
    images={[AdditionAnimation, SubstractionAnimation]}
    captionsUnderImages={[
        `Transition animation for adding a row to the table. Consider using a background color to temporarily highlight the newly-added row.`,
        `Transition animation for removing a row from the table.`,
    ]}
/>

<Divider />

# Tables vs. Lists

<ImageGrid
    images={[ListVTableTable, ListVTableList]}
    caption={['A same set of data may be presented in tables (#1) or lists (#2), depends on the use cases.']}
/>

In most cases, we encourage you to organize your data into lists instead of tables. However, there is no clearly defined boundary between lists and tables. Below are a few factors you should consider when deciding how you want to present your data.

## Arrangement

Tables expose each data point into their own columns, allowing users to easily look up a row starting from any column. Lists, on the other hand, group their content row-by-row.

<ImageGrid
    images={[ArrangeTable, ArrangeList]}
    captionsUnderImages={[
        'Tables take up more space and is often the main focus of the page they are on.',
        'Lists are more horizontally compact and are frequently used for dashboards. Typography changes can give the text more visual hierarchy.',
    ]}
/>

Because of this, tables tend to take up a lot of horizontal space, therefore they are almost always the only main content on the page of a desktop application. You should not use tables in dashboards, where many widgets are competing for the space; you should also avoid using tables on mobile applications, where the viewport size is limited.

<ImageGrid
    images={[DashboardTable, PageBodyTable]}
    captionsUnderImages={[
        'AVOID: Avoid using tables in dashboards. Use lists instead.',
        'DO: Tables are usually the only main content on a page.',
    ]}
/>

A "tabular list" or a structured list that attempts to combine tables and lists together might result in a design that does not pick up the advantages of either pattern.

<ImageGrid
    images={[TabularList]}
    captionsUnderImages={[
        'CAUTION: Be careful when combining tables and lists together, as this diminishes the value of both.',
    ]}
    gridContainerProps={{ style: { justifyContent: 'flex-start' } }}
/>

## Eye Movement

Tables facilitate users who want to work across multiple different properties of a data point. Users often navigate down a column, find the desired value, jump to another column, navigating further down, before they exit their path. On the other hand, lists often have a primary property that the user would rely on for navigation. This can be icons, avatars, or primary list texts.

<ImageGrid
    images={[ReadTable, ReadList]}
    caption={[
        `If you do an eye tracing between when the user starts looking at their data set and when they decide to perform some actions, you would notice users' eye sights roam differently in these two structures.`,
        '1: In a table, users can start from any column / property, and navigate horizontally or vertically to the targeted item.',
        '2: In a list, users rely heavily on a primary property to navigate.',
    ]}
/>

If you expect your users to compare across multiple parameters before they can decide which row to interact with, you should use a table. If they mostly read your data row-by-row, you shall try structuring your data as a list.

<ImageGrid
    images={[ColumnOrder1, ColumnOrder2]}
    caption={[
        `Users are more likely to find a user by their name or their role, not by their email address or phone number. Therefore, you should arrange the name and the role columns to the left, followed by phone number and email (#1). Email addresses and phone numbers should not show up before the role column (#2).`,
    ]}
    captionsUnderImages={['', 'DONT:']}
/>

## Property Name

In tables, you would call out properties of each data entry only once in the header row. In lists, however, either the values are clear enough on their own without explanations, or property names have to be included in every list item.

<ImageGrid
    images={[ImplicitValueTable, ImplicitValueList]}
    captionsUnderImages={[
        `The values are explained by the table header row.`,
        `1: It is not clear what those values in the subtitle mean.   2: Be careful when calling out property names in lists, as they weaken the scanability.`,
    ]}
/>

## Consumer-Facing Applications

Avoid using tables in consumer-facing applications. Lists mentally match real-world individual objects, while tables can be more abstract. Use tables only if your users really need to examine technical details.

<Divider />

# Responsive

In general, **we do not encourage tables on mobile platforms**, as table-related interactions tend to be complicated for small viewports, and mobile phones also often lack the computational power to process massive data set.

<ImageGrid
    images={[TableOnMobile]}
    regularWidth
    caption={`Users can only see a very small portion of the table through mobile devices.`}
/>

## Understanding Users' Goal

Before you design a table structure for a mobile application, you should conduct user researches and have a clear understanding of users' intentions. When they land on this page, Do they desire to do complicated cross-comparison between multiple rows and columns? Is a full table necessary?

For industrial applications, your users would often be using a mobile app when they are out in the field. They are paying more attention to their surroundings, so keep the mobile app interaction minimal.

## Breaking Down Tables into Lists

If a user only needs a few parameters to identify the correct data entry and make decisions, a list with a few selected data points would suffice.

<ImageGrid
    images={[HomePagePreview, TableStackedAsList]}
    captionsUnderImages={[
        `On a crowded page, show a preview of the table content, with the option to view the full table in a dedicated page.`,
        `Stack each property into a list item, with the ability to click into a list item to view the full item details.`,
    ]}
/>

## Pagination

Pagination is especially helpful on hand-held devices to reduce the load of both the server and the client-side render.

<ImageGrid
    images={[MobilePagination]}
    captionsUnderImages={[
        `Pagination is often used to reduce the page load. If not conflicting with other gestures, consider also adding left / right swipes to go to the previous / next page.`,
    ]}
    gridContainerProps={{ style: { justifyContent: 'flex-start' } }}
/>

> Be careful using pagination with multi-selection, as it is unclear whether the selection gets preserved when the page number changes.

## Native Mobile Gestures

In native mobile applications, you may also consider embedding action gestures common for touch screens, such as long-press and swipe.

<MaterialDesignDescription title={'Gestures'} url={`https://material.io/design/interaction/gestures.html`} />

However, these gestures should never be the only way to perform an action. For example, if your application is able to delete a table row, users may be able to either (1) left-swipe to bring up a contextual menu with a delete option, or (2) click into the target row, which opens a new page that contains a delete button.

## Landscape Mode

If a full table view is desired on mobile devices, consider offering a landscape view so that more columns would be visible at once.

<ImageGrid images={[LandscapeTable]} caption={`Use the landscape mode for viewing the full table.`} regularWidth />

However, most applications are meant to be used mainly on the portrait mode. In this case, you need to call out the option.

<ImageGrid
    images={[InviteToLandscapeX, InviteToLandscapeCountdown]}
    caption={`For example, you can use a chip button to "invite" users to the landscape view.`}
/>

<Divider />

# Design Specifications

<ImageGrid
    images={[SpecSize, SpecTypography, SpecPagination]}
    captionsUnderImages={[`Dimensions`, `Colors and typography`, `Pagination`]}
    regularWidth
/>

<MaterialDesignDescription
    title={'Data Tables'}
    description={`For additional instructions, refer to Material Design's design specs.`}
    url={`https://material.io/components/data-tables#specs`}
/>

<Divider />

# Developers

Use the following components to implement this pattern:

**Angular** and **Ionic**:

-   Angular Material
    -   [Table](https://material.angular.io/components/table/overview)

**React**:

-   Material UI
    -   [Table](https://mui.com/components/tables/)

**React Native**:

-   React Native Paper
    -   [Data Table](https://callstack.github.io/react-native-paper/data-table.html)
