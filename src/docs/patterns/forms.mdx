import { DemoCard, ImageGrid, MaterialDesignDescription, Divider } from '../../app/components';
import SummaryImage from '../../app/assets/design-patterns/form-validation/form-validation.svg';
// import Image1 from '../../app/assets/design-patterns/form-validation/form-validation-interaction.png';
// import Image2 from '../../app/assets/design-patterns/form-validation/form-validation-feedback.png';
// import Image3 from '../../app/assets/design-patterns/form-validation/form-validation-variation.png';
import Image4 from '../../app/assets/design-patterns/form-validation/form-validation-password-entering.png';
import Image5 from '../../app/assets/design-patterns/form-validation/form-validation-password-error.png';
import Image6 from '../../app/assets/design-patterns/form-validation/form-validation-password-complete.png';
import OnBlurImage from '../../app/assets/design-patterns/form-validation/verify-input-on-blur.png';
import OnChangeImage from '../../app/assets/design-patterns/form-validation/verify-input-on-change.png';
import OnPageChangeImage from '../../app/assets/design-patterns/form-validation/verify-input-on-page-change.png';
import SumbitButtonLocationImage from '../../app/assets/design-patterns/form-validation/submit-button-location.png';
import NextButtonUsageImage from '../../app/assets/design-patterns/form-validation/next-button-usage.png';
import SubmitButtonOnChangeImage from '../../app/assets/design-patterns/form-validation/submit-button-on-change.png';
import SubmitButtonAutoSubmitImage from '../../app/assets/design-patterns/form-validation/submit-button-auto-submit.png';
import SubmitButtonOnBlurImage from '../../app/assets/design-patterns/form-validation/submit-button-on-blur.png';
import SubmitButtonOnClickImage from '../../app/assets/design-patterns/form-validation/submit-button-on-click.png';
import Specs1Image from '../../app/assets/design-patterns/form-validation/specs-1.png';
import Specs2Image from '../../app/assets/design-patterns/form-validation/specs-2.png';
import Specs3Image from '../../app/assets/design-patterns/form-validation/specs-3.png';

# Form Validation Patterns

<ImageGrid images={[SummaryImage]} regularWidth />

Forms are an integral part of many applications, particularly during the [user registration](/patterns/login) phase. One of the most important parts of working with forms is properly validating the information that users enter into them. In general, PX Blue follows the form behaviors explained in detail by Material Design.

<React.Fragment>
    <MaterialDesignDescription title={'Text Fields'} url={'https://material.io/components/text-fields/'} />
    <DemoCard repository={'form-validation'} angular react />
    <Divider />
</React.Fragment>

# Behaviors

## Optional vs. Required Fields

When using a mixture of optional and required fields in a form, the inputs should be labeled appropriately.

If most of the fields are required, you should call out the fields that are optional. These fields should be labeled with an appropriate descriptor, followed by "optional" in parentheses.

Conversely, if most of your fields are optional, you should only call out the required fields. These should be identified by an asterisk (\*) after the field label. There should be a descriptor nearby that indicates that a \* means the field is required.

## Form Length

The form should not be too lengthy -- no more than the screen height on the mobile device, and no more than half of the desktop screen. Consider breaking long forms into subsections or multiple pages using tabs and [steppers](/patterns/steppers).

## Form Field Requirements

<ImageGrid images={[Image4, Image5, Image6]} caption={'A common application of form validation -- reset password.'} />

If your form fields have complex requirements for valid values, you can list these criteria below the input. A common use case for this is when displaying password complexity requirements.

## Handling Errors

If there is an error with the data entered into a field, the field should indicate to the user that there is a problem. Label and helper text should be changed to a red color and a warning icon should appear in the text input. The error message should be displayed in the helper text location below the field (any existing helper text should be replaced with the error message).

Error messages should be succinct and should not provide information that could compromise security (e.g., "Invalid Credentials" instead of "Incorrect Password").

## When to Verify User Input

In general, there are three acceptable times to perform form field verification:

-   on blur: the field is verified when the user clicks away from it
-   on change: the field is dynamically verified on each keystroke or change in the value
-   manually: fields are verified after performing a specific action (such as clicking a button)

### Verifying on Blur

In order to avoid distracting or confusing a user, most text fields should verify input when the field loses focus. Error messages should not appear until the user is finished entering data and the field is no longer in focus.

<ImageGrid
    images={[OnBlurImage]}
    regularWidth
    caption={[
        '1: Do not check for validity or display error messages when the user is typing in the field.',
        '2: The user is finished and the input has lost focus (i.e., "blurred"). Now the input should be verified.',
    ]}
/>

### Verifying on Change

Some fields should verify the user input as it changes. The most common case for this type of verification is a new password field (or a confirm password field). The verification feedback should be displayed / updated each time the user makes a change to the input field.

<ImageGrid
    images={[OnChangeImage]}
    regularWidth
    caption={[
        '1: The password criteria checks shall be updated as the user changes their input.',
        '2: “Confirm Password” field should check for a match with password to give immediate feedback for when the user can proceed.',
    ]}
/>

### Verifying Manually

In some specific situations, you may need to defer verification or perform it for all fields in a form at once. This type of verification is common when the checks cannot be performed on the client (such as making an API call to verify a registration code, check user login credentials, or search for a device on the network). In most cases, you can do some preliminary checks using one of the two methods above (e.g., you can check if the email is a valid email before making the API call to verify the credentials).

<ImageGrid
    images={[OnPageChangeImage]}
    regularWidth
    caption={[
        'After the user clicks the submit button, the app waits for the server response, and displays an error message.',
        '1: The helper text will be replaced by the error message. ',
        '2: Use a circular progress indicator when waiting for responses from the server.',
    ]}
/>

## Submitting the Form

Typically, forms should have a button to submit the data or continue to the next part of the form (for long forms). Depending on what happens next, the button should be labeled "next", "finish", or similar. The button should be located at the bottom right corner of the form (bottom left for right-to-left languages).

<ImageGrid
    images={[SumbitButtonLocationImage]}
    regularWidth
    caption={[
        '1: On desktops, the button is placed in the bottom corner of the form.',
        '2: On mobile devices, the button is replaced by a button on native keyboard.',
    ]}
/>

On mobile, if there are multiple input fields on the screen, the keyboard button should say "next", unless you are on the last item of the page, in which case the keyboard button should say "done" or "submit". In this situation, depends on if you want your user to double check their input, either dismiss the keyboard upon clicking the button (blur away from the input field), or transition the UI to the next page (submit the form directly).

<ImageGrid
    images={[NextButtonUsageImage]}
    regularWidth
    caption={[
        ,
        '1: The user entered a valid input. Clicking "next" will autofocus the user to the next text field.',
        '2: The user entered an invalid input. Clicking "next" will display the error message but will not autofocus to the next text field.',
    ]}
/>

For screens like email verifications where there is only one input field with a specific length, and the user will almost never need to go back and double check their input, the submit button can be omitted.

<ImageGrid
    images={[SubmitButtonAutoSubmitImage]}
    regularWidth
    caption={
        'For the verification code screen, you can auto-submit the information once the user input reaches the required length (#2). After the verification code is recognized (#3), the screen pauses for a short moment before automatically moving to the next screen.'
    }
/>

### Disabling the Submit Button

In most cases, the submit button **should not** be disabled. The users should not be forced to search for what they are missing, or what they did wrong.

<ImageGrid
    images={[SubmitButtonOnClickImage]}
    regularWidth
    caption={
        'Do not disable the submit button. Instead, use error text to highlight the invalid input after the user clicks the button.'
    }
/>

This rule has an exception: on desktop applications, when there are less than four text fields, and all the fields are verified on change, we recommend you disable the submit button to indicate that there are some errors in the user input (invalid value, missing a required field).

<React.Fragment>
    <ImageGrid
        images={[SubmitButtonOnChangeImage]}
        regularWidth
        caption={
            'When your input field field is verified on change, disable the submit button until the user enters a valid input.'
        }
    />
    <ImageGrid
        images={[SubmitButtonOnBlurImage]}
        regularWidth
        caption={'The submit button is disabled until the user has entered something for all the required fields.'}
    />
</React.Fragment>
<Divider />

# Specs

<ImageGrid images={[Specs1Image, Specs2Image, Specs3Image]} regularWidth />
<Divider />

# Developers

We recommend using the following components to build this pattern:

**Angular** - Angular Material

-   [Form Field](https://material.angular.io/components/form-field/overview)
-   [Input](https://material.angular.io/components/input/overview)

**React** - Material-UI

-   [Text Field](https://material-ui.com/components/text-fields/#text-field)
